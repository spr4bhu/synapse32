#!/usr/bin/env python3
"""
Signal Tracer - VCD File Parser for RISC-V CPU Debugging

This module parses VCD (Value Change Dump) files generated by Verilator/Icarus
and extracts critical signals for debugging pipeline stall bugs.

Focus areas:
1. Write enable signals during stalls (Bug #1, #3)
2. Memory data register sampling during stalls (Bug #5)
3. Address decoding race conditions (Bug #6)
4. Valid bit and stall signal interactions
"""

import re
from pathlib import Path
from typing import Dict, List, Tuple, Optional
from collections import defaultdict
from dataclasses import dataclass


@dataclass
class SignalValue:
    """Represents a signal value at a specific time"""
    time: int
    value: int

    def __repr__(self):
        return f"@{self:time}: {self.value}"


@dataclass
class BugOccurrence:
    """Represents a detected bug occurrence"""
    cycle: int
    bug_type: str
    description: str
    signals: Dict[str, int]

    def __repr__(self):
        sig_str = ", ".join(f"{k}={v}" for k, v in self.signals.items())
        return f"[Cycle {self.cycle}] {self.bug_type}: {self.description}\n  Signals: {sig_str}"


class VCDParser:
    """Simple VCD file parser focused on signal extraction"""

    def __init__(self, vcd_file: str):
        self.vcd_file = Path(vcd_file)
        self.signals: Dict[str, str] = {}  # signal_name -> identifier
        self.identifiers: Dict[str, str] = {}  # identifier -> signal_name
        self.signal_values: Dict[str, List[Tuple[int, int]]] = defaultdict(list)
        self.timescale = "1ns"
        self.current_time = 0

    def parse(self):
        """Parse the VCD file"""
        if not self.vcd_file.exists():
            raise FileNotFoundError(f"VCD file not found: {self.vcd_file}")

        print(f"Parsing VCD file: {self.vcd_file}")

        with open(self.vcd_file, 'r') as f:
            in_definitions = True

            for line in f:
                line = line.strip()

                if not line:
                    continue

                # Parse definitions section
                if in_definitions:
                    if line.startswith('$var'):
                        self._parse_var_definition(line)
                    elif line.startswith('$timescale'):
                        parts = line.split()
                        if len(parts) > 1:
                            self.timescale = parts[1]
                    elif line.startswith('$enddefinitions'):
                        in_definitions = False
                        print(f"Found {len(self.signals)} signal definitions")

                # Parse value changes
                else:
                    if line.startswith('#'):
                        # Time marker
                        self.current_time = int(line[1:])
                    elif line.startswith('b'):
                        # Binary value change: bXXXX identifier
                        match = re.match(r'b([01x]+)\s+(\S+)', line)
                        if match:
                            value_str, ident = match.groups()
                            if ident in self.identifiers:
                                try:
                                    value = int(value_str, 2) if 'x' not in value_str else 0
                                    signal_name = self.identifiers[ident]
                                    self.signal_values[signal_name].append((self.current_time, value))
                                except ValueError:
                                    pass
                    elif len(line) >= 2 and line[0] in '01x':
                        # Single bit value change: 0identifier or 1identifier
                        value = 1 if line[0] == '1' else 0
                        ident = line[1:]
                        if ident in self.identifiers:
                            signal_name = self.identifiers[ident]
                            self.signal_values[signal_name].append((self.current_time, value))

        print(f"Parsed {len(self.signal_values)} signal traces")
        return self.signal_values

    def _parse_var_definition(self, line: str):
        """Parse a $var definition line"""
        # Format: $var wire 1 ! clk $end
        parts = line.split()
        if len(parts) >= 5:
            var_type = parts[1]  # wire, reg, etc.
            width = parts[2]
            identifier = parts[3]
            signal_name = parts[4]

            # Build full hierarchical name from remaining parts
            if len(parts) > 5 and parts[-1] == '$end':
                signal_name = ' '.join(parts[4:-1])

            self.signals[signal_name] = identifier
            self.identifiers[identifier] = signal_name

    def get_signal_value_at_time(self, signal_name: str, time: int) -> Optional[int]:
        """Get signal value at specific time"""
        if signal_name not in self.signal_values:
            return None

        values = self.signal_values[signal_name]
        if not values:
            return None

        # Find the last value change before or at this time
        last_value = None
        for t, v in values:
            if t > time:
                break
            last_value = v

        return last_value

    def find_signal_by_pattern(self, pattern: str) -> List[str]:
        """Find signals matching a regex pattern"""
        regex = re.compile(pattern)
        return [sig for sig in self.signals.keys() if regex.search(sig)]


class BugDetector:
    """Detects specific bug patterns in VCD trace"""

    def __init__(self, vcd_parser: VCDParser):
        self.parser = vcd_parser
        self.bugs: List[BugOccurrence] = []

    def detect_all_bugs(self) -> List[BugOccurrence]:
        """Run all bug detection patterns"""
        print("\n=== Running Bug Detection ===")

        self.detect_memory_write_during_stall()
        self.detect_writeback_during_stall()
        self.detect_memory_data_reg_sampling_during_stall()
        self.detect_address_decode_races()

        return self.bugs

    def detect_memory_write_during_stall(self):
        """Bug #1: Memory write enable asserted during cache stalls"""
        print("\n[Bug #1] Checking for memory write enables during stalls...")

        # Find relevant signals
        wr_enable_signals = self.parser.find_signal_by_pattern(r'wr_enable|mem.*write.*enable')
        cache_stall_signals = self.parser.find_signal_by_pattern(r'cache_stall')

        print(f"  Found wr_enable signals: {wr_enable_signals[:3]}")
        print(f"  Found cache_stall signals: {cache_stall_signals[:3]}")

        if not wr_enable_signals or not cache_stall_signals:
            print("  ‚ö†Ô∏è  Required signals not found in VCD")
            return

        # Get all time points from cache stall signal
        wr_enable = wr_enable_signals[0]
        cache_stall = cache_stall_signals[0]

        stall_times = [t for t, v in self.parser.signal_values[cache_stall] if v == 1]

        bug_count = 0
        for time in stall_times:
            wr_val = self.parser.get_signal_value_at_time(wr_enable, time)
            if wr_val == 1:
                cycle = time // 10  # Assuming 10ns clock period
                bug = BugOccurrence(
                    cycle=cycle,
                    bug_type="Bug #1: Memory Write During Stall",
                    description="wr_enable=1 while cache_stall=1",
                    signals={
                        'wr_enable': wr_val,
                        'cache_stall': 1,
                        'time': time
                    }
                )
                self.bugs.append(bug)
                bug_count += 1
                if bug_count <= 3:  # Print first 3
                    print(f"  üêõ {bug}")

        if bug_count > 0:
            print(f"  ‚ùå Found {bug_count} occurrences of Bug #1")
        else:
            print(f"  ‚úÖ No occurrences of Bug #1")

    def detect_writeback_during_stall(self):
        """Bug #3: Writeback write enable during stalls"""
        print("\n[Bug #3] Checking for writeback enables during stalls...")

        wr_en_signals = self.parser.find_signal_by_pattern(r'wr_en_out|wb.*wr_en')
        cache_stall_signals = self.parser.find_signal_by_pattern(r'cache_stall')

        if not wr_en_signals or not cache_stall_signals:
            print("  ‚ö†Ô∏è  Required signals not found in VCD")
            return

        print(f"  Found wr_en_out signals: {wr_en_signals[:3]}")

        wr_en = wr_en_signals[0]
        cache_stall = cache_stall_signals[0]

        stall_times = [t for t, v in self.parser.signal_values[cache_stall] if v == 1]

        bug_count = 0
        for time in stall_times:
            wr_val = self.parser.get_signal_value_at_time(wr_en, time)
            if wr_val == 1:
                cycle = time // 10
                bug = BugOccurrence(
                    cycle=cycle,
                    bug_type="Bug #3: Writeback During Stall",
                    description="wr_en_out=1 while cache_stall=1",
                    signals={
                        'wr_en_out': wr_val,
                        'cache_stall': 1,
                        'time': time
                    }
                )
                self.bugs.append(bug)
                bug_count += 1
                if bug_count <= 3:
                    print(f"  üêõ {bug}")

        if bug_count > 0:
            print(f"  ‚ùå Found {bug_count} occurrences of Bug #3")
        else:
            print(f"  ‚úÖ No occurrences of Bug #3")

    def detect_memory_data_reg_sampling_during_stall(self):
        """Bug #5: mem_data_reg changes during cache stalls"""
        print("\n[Bug #5] Checking for mem_data_reg sampling during stalls...")

        mem_data_signals = self.parser.find_signal_by_pattern(r'mem_data_reg')
        cache_stall_signals = self.parser.find_signal_by_pattern(r'cache_stall')

        if not mem_data_signals or not cache_stall_signals:
            print("  ‚ö†Ô∏è  Required signals not found in VCD")
            return

        print(f"  Found mem_data_reg signals: {mem_data_signals[:3]}")

        mem_data_reg = mem_data_signals[0]
        cache_stall = cache_stall_signals[0]

        # Find times when mem_data_reg changes
        reg_changes = self.parser.signal_values[mem_data_reg]

        bug_count = 0
        for time, value in reg_changes:
            # Check if we're in a stall at this time
            stall_val = self.parser.get_signal_value_at_time(cache_stall, time)
            if stall_val == 1:
                cycle = time // 10
                bug = BugOccurrence(
                    cycle=cycle,
                    bug_type="Bug #5: Memory Data Register Sampling During Stall",
                    description=f"mem_data_reg changed to 0x{value:08x} during cache_stall",
                    signals={
                        'mem_data_reg': value,
                        'cache_stall': 1,
                        'time': time
                    }
                )
                self.bugs.append(bug)
                bug_count += 1
                if bug_count <= 3:
                    print(f"  üêõ {bug}")

        if bug_count > 0:
            print(f"  ‚ùå Found {bug_count} occurrences of Bug #5")
        else:
            print(f"  ‚úÖ No occurrences of Bug #5")

    def detect_address_decode_races(self):
        """Bug #6: Address decoding race conditions"""
        print("\n[Bug #6] Checking for address decoding races...")

        # Look for data_mem_access and instr_mem_access signals
        data_access_signals = self.parser.find_signal_by_pattern(r'data_mem_access')
        instr_access_signals = self.parser.find_signal_by_pattern(r'instr_mem_access')
        read_enable_signals = self.parser.find_signal_by_pattern(r'cpu_mem_read_en')

        if not data_access_signals or not instr_access_signals or not read_enable_signals:
            print("  ‚ö†Ô∏è  Required signals not found in VCD")
            print(f"    data_mem_access: {data_access_signals}")
            print(f"    instr_mem_access: {instr_access_signals}")
            print(f"    cpu_mem_read_en: {read_enable_signals}")
            return

        data_access = data_access_signals[0]
        instr_access = instr_access_signals[0]
        read_enable = read_enable_signals[0]

        # Find times when both access signals are active (race condition)
        bug_count = 0
        for time, _ in self.parser.signal_values[read_enable]:
            data_val = self.parser.get_signal_value_at_time(data_access, time)
            instr_val = self.parser.get_signal_value_at_time(instr_access, time)

            # Both access signals high = race
            if data_val == 1 and instr_val == 1:
                cycle = time // 10
                bug = BugOccurrence(
                    cycle=cycle,
                    bug_type="Bug #6: Address Decode Race",
                    description="Both data_mem_access and instr_mem_access asserted",
                    signals={
                        'data_mem_access': data_val,
                        'instr_mem_access': instr_val,
                        'time': time
                    }
                )
                self.bugs.append(bug)
                bug_count += 1
                if bug_count <= 3:
                    print(f"  üêõ {bug}")

        if bug_count > 0:
            print(f"  ‚ùå Found {bug_count} occurrences of Bug #6")
        else:
            print(f"  ‚úÖ No occurrences of Bug #6")


def analyze_vcd(vcd_file: str) -> Dict:
    """Main entry point for VCD analysis"""
    parser = VCDParser(vcd_file)
    parser.parse()

    detector = BugDetector(parser)
    bugs = detector.detect_all_bugs()

    return {
        'parser': parser,
        'bugs': bugs,
        'bug_count': len(bugs),
        'bug_types': {bug.bug_type for bug in bugs}
    }


if __name__ == "__main__":
    import sys

    if len(sys.argv) < 2:
        print("Usage: python signal_tracer.py <vcd_file>")
        sys.exit(1)

    vcd_file = sys.argv[1]
    result = analyze_vcd(vcd_file)

    print(f"\n{'='*60}")
    print(f"ANALYSIS COMPLETE")
    print(f"{'='*60}")
    print(f"Total bugs found: {result['bug_count']}")
    print(f"Bug types: {', '.join(result['bug_types'])}")

    if result['bugs']:
        print("\n=== TOP 10 BUG OCCURRENCES ===")
        for bug in result['bugs'][:10]:
            print(bug)
